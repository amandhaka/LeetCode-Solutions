Say you have an array for which the i-th element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
```
Example 1:

Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
Example 2:

Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
```

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length==0)
			return 0;
		int[][] profits=new int[k+1][prices.length];
		for(int i=0;i<k+1;i++){
			profits[i][0]=0; // As the profit is zero on day one for all transactions
		}
		for(int i=0;i<prices.length;i++){
			profits[0][i]=0; //if we don't do any transaction profits would be zero for all days
		}
		/*
		This is a faster method as we are not calculating the max value again and again.
		because while deriving the formula we saw that a part of equation is same for all 
		transactions so we just store that in maxvalue.
		We can do this easier way but that will increase time complexity to n2K from nk
		In n2k when we are at ith day so we iterate over 0 to i-1 index and check for:
		profit ( buying on jth day and selling on ith day + profit obtained in one less 
		transaction upto jth element.) for example we have 2 5 11 5 90 and we are at 90 
		and 2nd transaction so We will find maximum from following:
		1. 90-2+0 (0 here is profit in last transaction upto 0)
		2. 90-5+3 (3 here is profit in last transaction which was 5-3)
		and so on. Draw DP table to understand better
		*/
		for(int t=1;t<k+1;t++){
			int maxTillNow=Integer.MIN_VALUE;
			for(int d=1;d<prices.length;d++){
				maxTillNow=Math.max(maxTillNow,profits[t-1][d-1]-prices[d-1]);
				profits[t][d]=Math.max(profits[t][d-1],prices[d]+maxTillNow);
			}
		}
		return profits[k][prices.length-1];
    }
}
```

```java

```
